ARM的分散加载文件(scatter)介绍

对于分散加载的概念，在《ARM体系结构与编程》书中第11章有明确介绍。

分散加载文件（即scatter file　后缀为.sct）是一个文本文件，通过编写一个分散加载文件来指定
ARM连接器在生成映像文件时如何分配RO,RW,ZI等数据的存放地址。
如果不用SCATTER文件指定，那么ARM连接器会按照默认的方式来生成映像文件，一般情况下我们是不需要使用分散加载文件的。

但在某些场合，我们希望把某些数据放在指定的地址处，那么这时候SCATTER文件就发挥了非常大的作用,而且SCATTER文件用起来非常简单好用。

举个例子：
比如像LPC2378芯片,具有多个不连续的SRAM，通用的RAM(SDRAM)是32KB，可是32KB不够用，我想把某
个.C中的RW数据放在USB的SRAM中，那么就可以通过SCATTER文件来完成这个功能。


下面是就这个例子作的说明：  这是一个标准的常用的分散加载文件，现在加注释于后，方便以后查阅：
;******************************************************************************
;
; SCATTER LOADING DEION
; ARM
; KEIL's uVision3
; (RealView Microprocessor Developer Kit)
;
; Filename : LPC2378_Flash.scat
;******************************************************************************
LR_IROM1 0x00000000 0x00080000   ;第一个加载域,名字为LR_IROM1,起始地址为0x0,大小为0x80000
{　　　　　　　　　　　　　　　　　 
	ER_IROM1 0x00000000 0x00080000 ;加载域中的[运行]时域,名为ER_IROM1,起始地址为0x0,大小为0x80000
	{
		vectors.o (VECT, +First) 	   ;将vectors.c编译后生成的文件vectors.o中的代码
		init.o (INIT) 				       ;以及init.o中的代码
		* (+RO)                      ;以及所有编译生成的RO属性的代码全部存放在运行时域ER_IROM1指定的地址范围内,存放方式:顺序存放
	} 

	RW_IRAM1 0x40000000 0x0000e800　;这是第二个[运行]时域,功能同上,其中*是代表具有()里面所指定属性的全部数据
	{ 
		*(+RW,+ZI) 					          ;与*功能相似的还有.ANY, 下面说明。
	} 								              ;The following declarations select the "two region model";

	;A default __user_initial_stackheap() will be used;
	ARM_LIB_HEAP  0x40007000 EMPTY 0x00000100 {} 	  ;指定堆地址
	ARM_LIB_STACK 0x40008000 EMPTY -0x00000E00 {}   ;指定栈地址(arm r13(sp)寄存器的值？)
}



下面是针对LPC2378的USB　SRAM作数据RAM使用的配置：
;******************************************************************************
;
; SCATTER LOADING DEION
; ARM
; KEIL's uVision3
; (RealView Microprocessor Developer Kit)
;
; Filename : LPC2378_Flash.scat
;******************************************************************************
LR_IROM1 0x00000000 0x00080000   ;;第一个加载域，名字为LR_IROM1，起始地址为0x0，大小为0x80000
{
    ER_IROM1 0x00000000 0x00080000   ;;加载域中的运行时域，名字为ER_IROM1, 起始地址为0x0，大小为0x80000
    {
        vectors.o (VECT, +First)
        init.o (INIT)
        * (+RO)
    }
    
    RW_IRAM1 0x40000000 0x0000e800
    {
        .ANY(+RW,+ZI)     ;;此处.ANY替换上面例子的*，是因为下面的一个执行域对指定的模块中的RW,ZI数据指定了存放地址
                          ;;用.ANY就可以把已经被指定的具有RW,ZI属性的数据排除
    }                     ;;The following declarations select the "two region model" ;


找了3个分散加载文件来分析：
1、7x256的flash.sct分散加载文件：
(如果不修改它的话,它就固定了加载地址和运行地址，
如果程序简单又比较小的话可能不会有问题，但是如果程序代码比较大，超出了那两个加载文件的定义大小可能就会出问题，
解决办法也很简单，直接修改.sct文件直到适合你的代码)

Load_region 0x100000 0x40000 {  //ro起始地址为0x100000，大小为0x40000
      Fixed_region 0x100000 0x40000 {
          *(cstartup +First)
          .ANY (+RO)
      }

      Relocate_region 0x200000 {  //rw和zi段的地址为0x200000
          *.o (VECTOR, +First)
          .ANY (+RW +ZI)
      }

      ARM_LIB_HEAP 0x20E000 EMPTY 0x1000 {}
      ARM_LIB_STACK 0x210000 EMPTY -0x1000 {}
}


2、sram.sct文件
(如果不修改它的话,它就固定了加载地址和运行地址，
如果程序简单又比较小的话可能不会有问题，但是如果程序代码比较大，超出了那两个加载文件的定义大小可能就会出问题，
解决办法也很简单，直接修改.sct文件直到适合你的代码)

Load_region 0x200000 0x10000 {
      Fixed_region 0x200000 {
          *.o (VECTOR, +First)
          .ANY (+RO)
      }

      Relocate_region +0 {
          *(cstartup +First)
          .ANY (+RW +ZI)
      }

      ScatterAssert((ImageLength(Fixed_region) + ImageLength(Relocate_region)) < 0xE000)

      ARM_LIB_HEAP 0x20E000 EMPTY 0x1000 {}
      ARM_LIB_STACK 0x210000 EMPTY -0x1000 {}
}

3、自定义的sram.sct
LR_IROM1 0x00200000 0x00008000  ; load region size_region 
{
    ER_IROM1 0x00200000 0x00008000 ; load address = execution address//加载域等于运行域
    { 
      *.o (RESET, +First)
      *(InRoot$$Sections)
      .ANY (+RO)
    }

    RW_IRAM1 0x00208000 UNINIT 0x00008000 ; RW data//rw和zi段
    {
      .ANY (+RW +ZI)
    }
}

前面两个分散加载文件是从别的地方拷过来的，用在自己的程序中可能会有问题，因为如果不修改它的话,它就固定了加载地址和运行地址，
如果程序简单又比较小的话可能不会有问题，但是如果程序代码比较大，超出了那两个加载文件的定义大小可能就会出问题，
解决办法也很简单，直接修改.sct文件直到适合你的代码。

更好的办法是--自己定义一个分散加载文件，在keil中勾选Use Memory Layout from Target Dialog，那么加载文件就是从你定义irom和iram等地址得到的，
如果不勾选的话就是通过你自己指定的加载文件来加载。

如果分散加载文件不对的话，可能出现的问题就是明明是在sram中调试程序，但是却能神奇的通过flash downloader下载到flash中去，
刚开始也是不解，后来才发现是分散加载文件有错误，我使用了一个指定的flash.sct分散加载文件，这样的话我设置的irom和iram都无效了，
编译器直接根据我指定的flash.sct来分布代码和加载代码，又查看了一下flash.sct文件是将代码加载到flash地址空间的，
这就是为什么在jlink-sram工程中也能通过flash downloader工具烧写代码到flash中去的原因。










; *************************************************************
; *** Scatter-Loading Description File generated by uVision ***
; *************************************************************

; Application code always starts at 0x28000 and has a maximum allowed size of 0x56000 bytes (344 KB)
; so that it can theoretically strech from the begining of sector 12 until the end of sector 27

LR_IROM1 0x28000 0x56000 ; load region size_region
{
  ER_IROM1 +0 0x1000  {  ; load address = execution address
   *.o (RESET, +First)
   *(InRoot$Sections)
   .ANY (+RO)
  }

  ; this region is used to export the software event function for quick invocation
  SOFTWARE_EVENT 0x29000 FIXED 0x60 {
        ; by the firmware in case of a failure
        SOFTWARE_EVENT.o (+RO)
  }

  ; this region is used to export the software event function for quick invocation
  SIGNAL_EVENT 0x29060 FIXED 0x5C {
        ; by the firmware in case of a failure
        FIRMWARE_TO_APP_RTX_SIGNAL_ROUTE.o (+RO)
  }

  ER_IROM2 +0 0X54FA0  {  ; load address = execution address
   .ANY (+RO)
  }

  RW_IRAM1 0x40000000 UNINIT {  ; RW data
  }

  RW_IRAM2_1 0x40000040 0x2000 {  ; RW data
        APPLICATION_IRAM_DUMMY.o (+RW +ZI)
  }

  RW_IRAM2_2 0x40002040 0xDFC0 {  ; RW data
        FILE_SYSTEM.o (+RW +ZI)
        .ANY (+RW +ZI)
  }

  RW_IRAM3 0x7FE00000 0x00004000  {
        LPC24_EMAC.o (+ZI +RW)
  }
  
  RW_XRAM1 0xA0000024 0x95FDC  {  ; RW data
        .ANY (+RW +ZI)
        APPLICATION_RAM_DISK_IMAGE.o (+RW +ZI)
        DEF_DECODE_COMMAND_DCU.o (+RW +ZI)
        DEF_DCU_FMM_MESSAGE.o (+RW +ZI)
        DEF_CHECKSUM.o (+RW +ZI)
        LCD.o (+RW +ZI)
  }
  
  RW_XRAM2 0xA0096000 0xC1AA04  {  ; RW data
        buffer.o (+RW +ZI)
  }
  
  RW_XRAM3 0xA0CB0A04 0x80C2BC  {  ; RW data
        MSCUSER_RAM_DRIVE.o (+RW +ZI)
  }
  
  RW_DATA_INTERFACE 0xA14BCCC0 UNINIT   {
        ; ****************************************
        ; * DO NOT MAP ANYTHING INTO THIS REGION *
        ; ****************************************
        ; DOING SO WILL BREAK THE DATA INTERFACE BETWEEN
        ; THE DCU APPLICATION AND DCU FIRMWARE
        ; SEE ABSOLUTE LOCALIZATION OF VARIABLES HERE
        ; IN 'DCU_DEF_INTERFACE.C'
  }
  
  RW_XROM1 0x80000000 0x80FFFFFF  {  ; NOR FLASH
  }
}


让MDK自己分配--选linker-usexxx

 
