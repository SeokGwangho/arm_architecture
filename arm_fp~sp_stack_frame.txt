ARM32/ARM64：  sp ~ fp == stack frame.


stack种类：
		进程栈/线程栈/内核栈/中断栈
		硬件栈/软件栈


先从基础知识开始复习。
-------------------------------------------------------------------------------
栈:
-------------------------------------------------------------------------------
其实就是一个存放数据的结构类型。
按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。

向栈中存储数据称为PUSH，
从栈中取数据称为POP。

大多数的处理器架构，都有实现硬件栈，并且有专们的栈指针寄存器，及专门的硬件指令，来完成 入栈/出栈 的操作：

	在 ARM 架构上，R13 (SP) 寄存器就用作栈指针寄存器，而 PUSH 是用于压栈的汇编指令，POP 则是出栈的汇编指令。

-------------------------------------------------------------------------------
栈作用：
-------------------------------------------------------------------------------
主要有2大作用:
	1.函数调用;
	2.进程切换;

------------------
1.函数调用：
------------------
	在不同的计算机体系结构里，有不同的做法。

	ARM 和 ARM64 使用的是ATPCS函数调用约定(ARM-Thumb Procedure Call Standard)。

	ARM：   Parameter1 ~ Parameter4 分别保存到 r0 ~ r3 寄存器中 ，剩下的Parameter从右往左一次入栈，返回值存放在 r0 中。
	ARM64： Parameter1 ~ Parameter8 分别保存到 x0 ~ x7 寄存器中 ，剩下的Parameter从右往左一次入栈，返回值存放在 r0 中。

	当然，函数的局部变量也保存在栈空间里。



	以ARM32为例，function_A()调用funtion_B()的stack的布局图如下：

	fp寄存器(r11) 和 sp(r13) 两个寄存器指向的区域，称为一个栈帧(stack frame)。

	函数调用一般都是嵌套着的，在同一时刻，栈中会有多个函数的信息。也就是说，每个未完成运行的函数，占用一个独立的连续区域，叫栈帧。

	stack frame里存放着函数的Parameters，局部变量，以及恢复前一栈帧所需的数据等:


	//
	function_A()
	{
		...
		function_B();
		...
	}

	       High memory address
				      +-----------------------+                ---+---
				      |        lr (r14)       |                   |
				      +-----------------------+                   |
				      |        sp (r13)       |                   |
				      +-----------------------+                   v
				      |        fp (r11)       |           function_A() Stack Frame
				      +-----------------------+                   ^
				      | Func Local variables  |                   |
				      +-----------------------+                   |
	       Low memory address     | Function Parameters   |                   |
				      +------------------------<------ fp      -------
				      |        lr (r14)       |                   |
				      +-----------------------+                   |
				      |        sp (r13)       |                   v
				      +-----------------------+
				      |        fp (r11)       |           function_B() Stack Frame
				      +-----------------------+
				      | Func Local variables  |                   ^
				      +-----------------------+                   |
				      | Function Parameters   |                   |
				      +-----------------------+<------ sp      ---+---


	如上图假设当前运行在funtion_B()里面，那当前的fp和sp寄存器所指示的区域就是function_B()的栈帧。
	当函数B返回到函数A时候，栈帧B里保存的sp和fp寄存器所构造的另一个栈，就是栈帧A了。


	所以，栈是链接起来的‘桢’的一个列表，按递减地址次序分配栈的每一块。

	寄存器 sp 总是指向在最当前桢中最低的使用的地址。

	其他CPU体系结构中的SP栈指针，都是指向栈顶的，
	但是ARM的栈是自减栈，栈是向下生长的，也就是栈底处于高地址处，栈顶处于低地址处。

------------------
2.进程切换:
------------------
	在Linux系统中，一个进程可以在内核态(kernel mode)或者用户态(user mode)下执行，因此，Linux内核栈和用户栈是分开的。
	用户栈用于进程在用户态下临时保存调用函数的参数，局部变量等数据。
	内核栈则含有内核程序执行函数调用时的信息。
							-----<< Linux内核完全注释 >> (Kernel 0.11 赵炯)
	
	每个进程的生命周期中，必然会通过System Call陷入内核。
	每个进程都有自己的内核空间栈，这个是在fork()的时候就分配好的。进程切换的时候，需要把前进程的上下文，保存到前进程的内核栈里。

	进程跑在用户空间，需要一个栈。
	进程跑在内核空间，需要一个栈。

	中断栈空间，另议。

